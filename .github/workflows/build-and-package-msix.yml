name: Build & Package ScoreGenius Appx

on:
  workflow_dispatch:

jobs:
  package-appx:
    runs-on: windows-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Compute dynamic version
        id: version
        shell: pwsh
        run: |
          $base = "1.12"
          $runnum = $env:GITHUB_RUN_NUMBER
          $version = "$base.$runnum.0"
          Write-Output "version=$version" | Out-File -Encoding ASCII -NoNewline $env:GITHUB_OUTPUT
          "Computed version: $version"

      # 1) Ensure we have a PFX (generate self-signed if secrets are absent)
      - name: Ensure code signing certificate exists (generate if secrets absent)
        shell: pwsh
        env:
          SCOREGENIUS_PFX_B64: ${{ secrets.SCOREGENIUS_PFX_B64 }}
          SCOREGENIUS_PFX_PASSWORD: ${{ secrets.SCOREGENIUS_PFX_PASSWORD }}
        run: |
          if (-not $env:SCOREGENIUS_PFX_B64) {
            "No external PFX; generating self-signed CodeSigning cert."
            $cert = New-SelfSignedCertificate `
              -Subject "CN=ScoreGeniusTest,O=SG,L=NY,C=US" `
              -Type CodeSigningCert `
              -KeyAlgorithm RSA -KeyLength 2048 `
              -HashAlgorithm SHA256 `
              -NotAfter (Get-Date).AddYears(3)

            $pwd     = ConvertTo-SecureString "StrongPfxPass123" -AsPlainText -Force
            $pfxPath = "$PWD\scoregenius_generated.pfx"
            Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pwd

            $b64 = [Convert]::ToBase64String([IO.File]::ReadAllBytes($pfxPath))
            echo "SCOREGENIUS_PFX_B64=$b64" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
            echo "SCOREGENIUS_PFX_PASSWORD=StrongPfxPass123" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
            "Generated cert Thumbprint: $($cert.Thumbprint)"
          } else {
            "Using provided PFX from secrets."
            if (-not $env:SCOREGENIUS_PFX_PASSWORD) { throw "SCOREGENIUS_PFX_PASSWORD is missing in secrets." }
            echo "SCOREGENIUS_PFX_B64=$($env:SCOREGENIUS_PFX_B64)" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
            echo "SCOREGENIUS_PFX_PASSWORD=$($env:SCOREGENIUS_PFX_PASSWORD)" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
          }

      # 2) Decode + validate the PFX
      - name: Decode + validate PFX (sanitize, password-check)
        shell: pwsh
        run: |
          if (-not $env:SCOREGENIUS_PFX_B64) { throw "SCOREGENIUS_PFX_B64 missing after generation/secrets step." }

          $cleaned = ($env:SCOREGENIUS_PFX_B64 -replace '[^A-Za-z0-9+/=]', '')
          try { [void][Convert]::FromBase64String($cleaned) } catch { throw "PFX secret is not valid base64 after sanitization." }

          $pfxPath = Join-Path $env:RUNNER_TEMP "scoregenius.pfx"
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($cleaned))
          echo "PFX_PATH=$pfxPath" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
          "Decoded PFX to: $pfxPath"

          certutil -f -p $env:SCOREGENIUS_PFX_PASSWORD -dump $pfxPath | Out-Null
          if ($LASTEXITCODE -ne 0) { throw "PFX failed to open with provided password." }
          "PFX password validated."

      # 3) Trust the signer on the runner + export metadata for later steps
      - name: Trust signing cert on runner (so verify /pa passes)
        shell: pwsh
        run: |
          if (-not $env:PFX_PATH) { throw "PFX_PATH not set." }
          if (-not $env:SCOREGENIUS_PFX_PASSWORD) { throw "SCOREGENIUS_PFX_PASSWORD not set." }

          $secure = ConvertTo-SecureString $env:SCOREGENIUS_PFX_PASSWORD -AsPlainText -Force
          $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2(
            $env:PFX_PATH, $secure,
            [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
          )

          $thumb   = $cert.Thumbprint
          $subject = $cert.Subject
          $self    = ($cert.Subject -eq $cert.Issuer)

          echo "CERT_THUMBPRINT=$thumb"     | Out-File -Encoding ascii -Append $env:GITHUB_ENV
          echo "CERT_PUBLISHER=$subject"    | Out-File -Encoding ascii -Append $env:GITHUB_ENV
          echo "SELF_SIGNED=$([int]$self)"  | Out-File -Encoding ascii -Append $env:GITHUB_ENV

          "Signer: $subject"
          "Thumbprint: $thumb"
          "Self-signed: $self"

          $cerPath = Join-Path $env:RUNNER_TEMP "signer.cer"
          [IO.File]::WriteAllBytes($cerPath, $cert.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert))

          if ($self) {
            Import-Certificate -FilePath $cerPath -CertStoreLocation Cert:\CurrentUser\Root          | Out-Null
            Import-Certificate -FilePath $cerPath -CertStoreLocation Cert:\CurrentUser\TrustedPeople | Out-Null
            "Installed self-signed cert to CurrentUser\Root and CurrentUser\TrustedPeople."
          } else {
            Import-Certificate -FilePath $cerPath -CertStoreLocation Cert:\CurrentUser\TrustedPeople | Out-Null
            "Installed signer to CurrentUser\TrustedPeople."
          }

          "Root contains signer?           " + [bool](Get-ChildItem Cert:\CurrentUser\Root          | Where-Object Thumbprint -eq $thumb)
          "TrustedPeople contains signer?  " + [bool](Get-ChildItem Cert:\CurrentUser\TrustedPeople | Where-Object Thumbprint -eq $thumb)

      # 4) Patch manifest + appinstaller (version + publisher DN + constant URI)
      - name: Patch AppxManifest + AppInstaller (version/publisher/URI)
        shell: pwsh
        run: |
          $version = '${{ steps.version.outputs.version }}'
          $publisher = $env:CERT_PUBLISHER

          # AppxManifest.xml
          $manifest = "frontend/windows_package/PackageRoot/AppxManifest.xml"
          if (-not (Test-Path $manifest)) { throw "Manifest not found at $manifest" }
          [xml]$xml = Get-Content -Raw -Encoding UTF8 $manifest
          if (-not $xml.Package.Identity) { throw "Identity element missing in AppxManifest.xml" }

          $xml.Package.Identity.Version = $version
          if ($publisher) { $xml.Package.Identity.Publisher = $publisher }

          $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
          [System.IO.File]::WriteAllText($manifest, $xml.OuterXml, $utf8NoBom)
          "Manifest patched to version $version and publisher '$publisher'."

          # ScoreGenius.appinstaller
          $ai = "frontend/app/ScoreGenius.appinstaller"
          if (-not (Test-Path $ai)) { throw "AppInstaller not found at $ai" }
          [xml]$doc = Get-Content -Raw -Encoding UTF8 $ai
          $doc.AppInstaller.Version = $version
          $doc.AppInstaller.MainPackage.Uri = "https://scoregenius.io/app/ScoreGenius.appxbundle"
          if ($doc.AppInstaller.MainPackage -and ($doc.AppInstaller.MainPackage | Get-Member -Name SetAttribute)) {
            if ($doc.AppInstaller.MainPackage.HasAttribute("Publisher") -and $publisher) {
              $doc.AppInstaller.MainPackage.SetAttribute("Publisher", $publisher)
            }
          }
          [System.IO.File]::WriteAllText($ai, $doc.OuterXml, $utf8NoBom)
          "AppInstaller updated to $version, constant URI, and publisher (if attribute existed)."

      # 5) Locate SDK tools (x64 preferred)
      - name: Locate SDK tools (MakeAppx + x64 SignTool)
        shell: pwsh
        run: |
          $binRoot = 'C:\Program Files (x86)\Windows Kits\10\bin\'

          $makeappx = Get-ChildItem $binRoot -Recurse -Filter MakeAppx.exe | Where-Object { $_.FullName -match '\\x64\\' } | Sort-Object FullName -Descending | Select-Object -First 1
          if (-not $makeappx) {
            $makeappx = Get-ChildItem $binRoot -Recurse -Filter MakeAppx.exe | Sort-Object FullName -Descending | Select-Object -First 1
          }
          $signtool = Get-ChildItem $binRoot -Recurse -Filter signtool.exe | Where-Object { $_.FullName -match '\\x64\\' } | Sort-Object FullName -Descending | Select-Object -First 1

          if (-not $makeappx) { throw "MakeAppx.exe not found." }
          if (-not $signtool) { throw "signtool.exe (x64) not found." }

          echo "MAKEAPPX=$($makeappx.FullName)" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
          echo "SIGNTOOL=$($signtool.FullName)" | Out-File -Encoding ascii -Append $env:GITHUB_ENV

          "Using MakeAppx: $($makeappx.FullName)"
          "Using SignTool: $($signtool.FullName)"
          "MakeAppx version: $((Get-Item $makeappx.FullName).VersionInfo.FileVersion)"
          "SignTool version: $((Get-Item $signtool.FullName).VersionInfo.FileVersion)"

      # 6) Pack -> sign .appx -> bundle -> sign .appxbundle -> verify both (with timeouts + TSA fallback)
      - name: Pack, sign .appx; bundle, sign .appxbundle; verify
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:PFX_PATH) { throw "PFX_PATH not set." }
          if (-not $env:SCOREGENIUS_PFX_PASSWORD) { throw "SCOREGENIUS_PFX_PASSWORD not set." }
          if (-not $env:MAKEAPPX -or -not $env:SIGNTOOL) { throw "MAKEAPPX or SIGNTOOL not set." }

          $packageRoot = 'frontend/windows_package/PackageRoot'
          $version     = '${{ steps.version.outputs.version }}'
          $appxName    = "ScoreGenius_${version}.appx"
          $bundleName  = "ScoreGenius_${version}.appxbundle"
          $timeoutSec  = 75

          # Helper: run a process with timeout and capture logs
          function Invoke-ToolWithTimeout([string]$exe, [string[]]$args, [int]$timeoutSec, [string]$label) {
            $out = Join-Path $env:RUNNER_TEMP ("$($label)_out_" + (Get-Random) + ".log")
            $err = $out + ".err"
            "-> $label: $exe $($args -join ' ')"
            $proc = Start-Process -FilePath $exe -ArgumentList $args -NoNewWindow -PassThru -RedirectStandardOutput $out -RedirectStandardError $err
            try {
              Wait-Process -Id $proc.Id -Timeout $timeoutSec -ErrorAction SilentlyContinue | Out-Null
              if (-not $proc.HasExited) {
                "!! $label timed out after $timeoutSec s. Killing process."
                Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
                $code = 999
              } else {
                $code = $proc.ExitCode
              }
            } finally {
              if (Test-Path $out) { Get-Content $out | ForEach-Object { $_ } }
              if (Test-Path $err) { Get-Content $err | ForEach-Object { $_ } }
            }
            return $code
          }

          function Sign-Once([string]$filePath, [string]$tsaUrl) {
            $args = @('sign','/v','/debug','/fd','SHA256','/td','SHA256','/f', $env:PFX_PATH, '/p', $env:SCOREGENIUS_PFX_PASSWORD)
            if ($tsaUrl) { $args += @('/tr', $tsaUrl) }
            $args += @("$filePath")
            return (Invoke-ToolWithTimeout $env:SIGNTOOL $args $timeoutSec "signtool_sign_$([IO.Path]::GetFileName($filePath))")
          }

          function Sign-WithPolicy([string]$filePath) {
            if ($env:SELF_SIGNED -eq '1') {
              "Self-signed build: signing WITHOUT timestamp for speed."
              $code = Sign-Once $filePath $null
              if ($code -ne 0) { throw "Signing failed (self-signed, no timestamp) for $filePath (code $code)" }
              "Signed (no timestamp): $filePath"
              return
            }

            # Real PFX: primary TSA -> backup TSA -> no timestamp fallback
            "Signing $filePath (primary TSA)"
            $code = Sign-Once $filePath "http://timestamp.digicert.com"
            if ($code -ne 0) {
              "Primary failed (code $code). Retrying with backup TSA."
              Start-Sleep -Seconds 2
              $code = Sign-Once $filePath "http://timestamp.sectigo.com"
              if ($code -ne 0) {
                "Backup TSA failed (code $code). Final fallback: signing WITHOUT timestamp."
                $code = Sign-Once $filePath $null
                if ($code -ne 0) { throw "Signing failed (no timestamp fallback) for $filePath (code $code)" }
                "Signed (no timestamp fallback): $filePath"
              } else {
                "Signed with backup TSA: $filePath"
              }
            } else {
              "Signed with primary TSA: $filePath"
            }
          }

          $verifyTimeoutSec = 30

          function Verify-Signature([string]$filePath) {
            # Use the same timeout wrapper we built for signing
            $args = @('verify','/pa','/all',"$filePath")
            $code = Invoke-ToolWithTimeout $env:SIGNTOOL $args $verifyTimeoutSec "signtool_verify_$([IO.Path]::GetFileName($filePath))"

            if ($code -eq 999) {
              # Timed out
              if ($env:SELF_SIGNED -eq '1') {
                "Verify timed out after $verifyTimeoutSec s (self-signed). Proceeding."
                return
              } else {
                throw "Verify timed out after $verifyTimeoutSec s for $filePath (real PFX)."
              }
            }

            if ($code -ne 0) {
              if ($env:SELF_SIGNED -eq '1') {
                "Verify failed (self-signed), but signature exists and signer is locally trusted. Proceeding."
                return
              } else {
                throw "Signature verification failed for $filePath (exit $code)."
              }
            }

            "Verified signature: $filePath"
          }

          # Pack .appx
          & $env:MAKEAPPX pack /o /d $packageRoot /p $appxName
          if (-not (Test-Path $appxName)) { throw "Packaging .appx failed." }
          "Created .appx: $appxName"

          # Sign payload (.appx) then verify
          Sign-WithPolicy $appxName
          Verify-Signature $appxName

          # Build bundle (.appxbundle)
          $bundleLayout = Join-Path $env:RUNNER_TEMP "bundlelayout"
          Remove-Item -Recurse -Force $bundleLayout -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $bundleLayout | Out-Null
          Copy-Item $appxName -Destination $bundleLayout

          & $env:MAKEAPPX bundle /o /bv $version /d $bundleLayout /p $bundleName
          if (-not (Test-Path $bundleName)) { throw "Bundling failed." }
          "Created bundle: $bundleName"

          # Sign bundle then verify
          Sign-WithPolicy $bundleName
          Verify-Signature $bundleName

          # Constant name for hosting
          Copy-Item $bundleName "ScoreGenius.appxbundle" -Force
          echo "FINAL_PACKAGE=ScoreGenius.appxbundle" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
          "Final bundle (constant name): ScoreGenius.appxbundle"

      - name: Upload artifact (bundle + appinstaller)
        uses: actions/upload-artifact@v4
        with:
          name: scoregenius-package
          path: |
            ${{ env.FINAL_PACKAGE }}
            frontend/app/ScoreGenius.appinstaller

      - name: Draft GitHub Release (attach both)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ steps.version.outputs.version }}"
          name: "ScoreGenius v${{ steps.version.outputs.version }}"
          draft: true
          files: |
            ${{ env.FINAL_PACKAGE }}
            frontend/app/ScoreGenius.appinstaller
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
