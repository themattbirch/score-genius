name: Build & Package ScoreGenius Appx

on:
  workflow_dispatch:

jobs:
  package-appx:
    runs-on: windows-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Compute dynamic version
        id: version
        run: |
          $base = "1.12"
          $runnum = $env:GITHUB_RUN_NUMBER
          $version = "$base.$runnum.0"
          Write-Output "version=$version" | Out-File -Encoding ASCII -NoNewline $env:GITHUB_OUTPUT

      - name: Patch manifest version
        shell: pwsh
        run: |
          $manifest = "frontend/windows_package/PackageRoot/AppxManifest.xml"
          if (-not (Test-Path $manifest)) { throw "Manifest not found at $manifest" }
          $version = '${{ steps.version.outputs.version }}'
          [xml]$xml = Get-Content -Raw -Encoding UTF8 $manifest
          $xml.Package.Identity.Version = $version
          $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
          [System.IO.File]::WriteAllText($manifest, $xml.OuterXml, $utf8NoBom)
          Write-Output "Manifest patched to version $version"

      - name: Patch AppInstaller to match manifest + version
        shell: pwsh
        run: |
          $version  = '${{ steps.version.outputs.version }}'
          $manifest = 'frontend/windows_package/PackageRoot/AppxManifest.xml'
          $ai       = 'frontend/app/ScoreGenius.appinstaller'

          if (-not (Test-Path $manifest)) { throw "Manifest not found at $manifest" }
          if (-not (Test-Path $ai))       { throw "AppInstaller not found at $ai" }

          [xml]$m = Get-Content -Raw -Encoding UTF8 $manifest
          $name      = $m.Package.Identity.Name
          $publisher = $m.Package.Identity.Publisher

          [xml]$doc = Get-Content -Raw -Encoding UTF8 $ai
          $ns = New-Object System.Xml.XmlNamespaceManager($doc.NameTable)
          $ns.AddNamespace('ai','http://schemas.microsoft.com/appx/appinstaller/2017/2')

          # Ensure <MainBundle> exists (convert <MainPackage> if present)
          $mainBundle = $doc.SelectSingleNode('/ai:AppInstaller/ai:MainBundle', $ns)
          if (-not $mainBundle) {
            $mainPackage = $doc.SelectSingleNode('/ai:AppInstaller/ai:MainPackage', $ns)
            if ($mainPackage) {
              $mainBundle = $doc.CreateElement('MainBundle', $doc.DocumentElement.NamespaceURI)
              foreach ($attr in $mainPackage.Attributes) { $mainBundle.SetAttribute($attr.Name, $attr.Value) }
              [void]$doc.DocumentElement.ReplaceChild($mainBundle, $mainPackage)
            } else {
              $mainBundle = $doc.CreateElement('MainBundle', $doc.DocumentElement.NamespaceURI)
              [void]$doc.DocumentElement.AppendChild($mainBundle)
            }
          }

          # Stamp values
          $doc.DocumentElement.SetAttribute('Version', $version)
          $mainBundle.SetAttribute('Name',      $name)
          $mainBundle.SetAttribute('Publisher', $publisher)
          $mainBundle.SetAttribute('Version',   $version)
          $mainBundle.SetAttribute('Uri',       'https://scoregenius.io/app/ScoreGenius.appxbundle')

          # Save UTF-8 no BOM
          $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
          [System.IO.File]::WriteAllText($ai, $doc.OuterXml, $utf8NoBom)

          "AppInstaller patched -> Name=$name | Publisher=$publisher | Version=$version"

      - name: Ensure code signing certificate exists
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SCOREGENIUS_PFX_B64: ${{ secrets.SCOREGENIUS_PFX_B64 }}
          SCOREGENIUS_PFX_PASSWORD: ${{ secrets.SCOREGENIUS_PFX_PASSWORD }}
        run: |
          if (-not $env:SCOREGENIUS_PFX_B64) {
            Write-Output "No external PFX provided; generating fresh RSA-2048 code-signing cert."
            $cert = New-SelfSignedCertificate `
              -Subject "CN=ScoreGeniusTest,O=SG,L=NY,C=US" `
              -Type CodeSigningCert `
              -KeyAlgorithm RSA -KeyLength 2048 `
              -HashAlgorithm SHA256 `
              -NotAfter (Get-Date).AddYears(3)

            $pwd     = ConvertTo-SecureString "StrongPfxPass123" -AsPlainText -Force
            $pfxPath = "$PWD\scoregenius_generated.pfx"

            Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pwd

            # Debug: show cert details
            Get-PfxCertificate $pfxPath | Format-List Subject,Thumbprint,NotAfter

            $b64 = [Convert]::ToBase64String([IO.File]::ReadAllBytes($pfxPath))
            Write-Output "Generated PFX base64 prefix: $($b64.Substring(0,80))..."
            Write-Output "Generated cert thumbprint: $($cert.Thumbprint)"

            echo "SCOREGENIUS_PFX_B64=$b64" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
            echo "SCOREGENIUS_PFX_PASSWORD=StrongPfxPass123" | Out-File -Encoding ascii -Append $env:GITHUB_ENV
          } else {
            Write-Output "External PFX provided; will sanitize and use it."
          }

      - name: Package Appxbundle and sign (with secret sanitization)
        id: bundle
        shell: pwsh
        env:
          # ✅ make secrets available here too (if present)
          SCOREGENIUS_PFX_B64: ${{ secrets.SCOREGENIUS_PFX_B64 }}
          SCOREGENIUS_PFX_PASSWORD: ${{ secrets.SCOREGENIUS_PFX_PASSWORD }}
        run: |
          $packageRoot = 'frontend/windows_package/PackageRoot'
          $version = '${{ steps.version.outputs.version }}'
          $appxName = "ScoreGenius_${version}.appx"
          $bundleName = "ScoreGenius_${version}.appxbundle"

          # --- sanitize and validate base64 PFX secret ---
          if ($env:SCOREGENIUS_PFX_B64) {
            $cleaned = ($env:SCOREGENIUS_PFX_B64 -replace '[^A-Za-z0-9+/=]', '')
            try {
              [Convert]::FromBase64String($cleaned) | Out-Null
            } catch {
              Write-Error "PFX secret is not valid base64 after sanitization."
              exit 1
            }
            $pfxPath = Join-Path $env:RUNNER_TEMP "scoregenius.pfx"
            [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($cleaned))
            Write-Output "Decoded and sanitized .pfx to $pfxPath"

            # Validate PFX loads with password
            certutil -f -p $env:SCOREGENIUS_PFX_PASSWORD -dump $pfxPath | Out-Null
            if ($LASTEXITCODE -ne 0) {
              Write-Error "PFX failed to load; bad password or corrupted content."
              exit 1
            }
            Write-Output "PFX validated."
          } else {
            Write-Output "No PFX base64 provided; signing will be skipped."
            $pfxPath = $null
          }

          # Locate tools
          $binRoot = 'C:\Program Files (x86)\Windows Kits\10\bin\'
          $makeappx = Get-ChildItem $binRoot -Recurse -Filter MakeAppx.exe |
                      Sort-Object FullName -Descending | Select-Object -First 1
          $signtool = Get-ChildItem $binRoot -Recurse -Filter signtool.exe |
                      Where-Object { $_.FullName -match '\\x64\\' } |
                      Sort-Object FullName -Descending | Select-Object -First 1

          if (-not $makeappx) { throw "MakeAppx.exe not found." }
          Write-Output "Using MakeAppx: $($makeappx.FullName)"
          if ($signtool) { Write-Output "Using SignTool: $($signtool.FullName)" }

          # Step 1: Pack .appx
          & $makeappx.FullName pack /d $packageRoot /p $appxName
          if (-not (Test-Path $appxName)) { throw "Packaging .appx failed." }
          Write-Output "Created .appx: $appxName"

          # Step 2: Bundle into .appxbundle (single-arch)
          $bundleLayout = Join-Path $env:RUNNER_TEMP "bundlelayout"
          Remove-Item -Recurse -Force $bundleLayout -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $bundleLayout | Out-Null
          Copy-Item $appxName -Destination $bundleLayout

          & $makeappx.FullName bundle /bv $version /d $bundleLayout /p $bundleName
          if (-not (Test-Path $bundleName)) { throw "Bundling failed." }
          Write-Output "Created bundle: $bundleName"

          # Step 3: Sign the bundle
          if ($signtool -and $pfxPath) {
            Write-Output "Signing .appxbundle with debug output..."
            & $signtool.FullName sign /debug /fd SHA256 /a /f $pfxPath /p $env:SCOREGENIUS_PFX_PASSWORD $bundleName
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Signing failed with code $LASTEXITCODE"
              exit $LASTEXITCODE
            }
            Write-Output "Signing succeeded."
          } else {
            Write-Output "Skipping signing (missing signtool or PFX)."
          }

          # ✅ expose for later steps (this was missing)
          echo "final_package=$bundleName" | Out-File -Encoding ascii -Append $env:GITHUB_OUTPUT
          "Exposed final_package output: $bundleName"

          # (Optional) keep the env var too if you like:
          echo "FINAL_PACKAGE=$bundleName" | Out-File -Encoding ascii -Append $env:GITHUB_ENV

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: scoregenius-package
          path: |
            ${{ steps.bundle.outputs.final_package }}
            frontend/app/ScoreGenius.appinstaller

      - name: Draft GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ steps.version.outputs.version }}"
          name: "ScoreGenius v${{ steps.version.outputs.version }}"
          draft: true
          files: |
            ${{ steps.bundle.outputs.final_package }}
            frontend/app/ScoreGenius.appinstaller
